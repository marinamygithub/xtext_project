/**
 * generated by Xtext 2.9.0
 */
package org.xtext.example.mydsl1.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.example.mydsl1.aDSL.Block;
import org.xtext.example.mydsl1.aDSL.Expression;
import org.xtext.example.mydsl1.aDSL.Member;
import org.xtext.example.mydsl1.aDSL.MemberSelection;
import org.xtext.example.mydsl1.aDSL.Method;
import org.xtext.example.mydsl1.aDSL.Parameter;
import org.xtext.example.mydsl1.aDSL.Statement;
import org.xtext.example.mydsl1.aDSL.VariableDef;
import org.xtext.example.mydsl1.aDSL.XClass;
import org.xtext.example.mydsl1.lib.ADSLLib;
import org.xtext.example.mydsl1.typing.ADSLTypeProvider;
import org.xtext.example.mydsl1.util.ADSLUtil;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ADSLScopeProvider extends AbstractDeclarativeScopeProvider {
  @Inject
  @Extension
  private ADSLTypeProvider _aDSLTypeProvider;
  
  @Inject
  @Extension
  private ADSLLib _aDSLLib;
  
  public IScope scope_VariableDef(final MemberSelection sel, final EReference r) {
    return this.computeScope(sel, r);
  }
  
  public IScope scope_SharedDef(final MemberSelection sel, final EReference r) {
    return this.computeScope(sel, r);
  }
  
  public IScope scope_Member(final MemberSelection sel, final EReference r) {
    return this.computeScope(sel, r);
  }
  
  public IScope computeScope(final MemberSelection sel, final EReference r) {
    IScope _xblockexpression = null;
    {
      IScope parentScope = IScope.NULLSCOPE;
      Expression _receiver = sel.getReceiver();
      final XClass type = this._aDSLTypeProvider.typeFor(_receiver);
      boolean _or = false;
      boolean _equals = Objects.equal(type, null);
      if (_equals) {
        _or = true;
      } else {
        boolean _isPrimitive = this.isPrimitive(type);
        _or = _isPrimitive;
      }
      if (_or) {
        return parentScope;
      }
      ArrayList<XClass> _classHierarchyWithObject = this._aDSLLib.getClassHierarchyWithObject(type);
      List<XClass> _reverseView = ListExtensions.<XClass>reverseView(_classHierarchyWithObject);
      for (final XClass c : _reverseView) {
        EList<Member> _members = c.getMembers();
        IScope _scopeFor = Scopes.scopeFor(_members, parentScope);
        parentScope = _scopeFor;
      }
      Iterable<EObject> _selectMembers = this.selectMembers(type, sel);
      _xblockexpression = Scopes.scopeFor(_selectMembers, parentScope);
    }
    return _xblockexpression;
  }
  
  public Iterable<EObject> selectMembers(final XClass type, final MemberSelection sel) {
    Iterable<EObject> _xifexpression = null;
    boolean _isMethodinvocation = sel.isMethodinvocation();
    if (_isMethodinvocation) {
      Iterable<Method> _methods = ADSLUtil.methods(type);
      Iterable<EObject> _fields = ADSLUtil.fields(type);
      _xifexpression = Iterables.<EObject>concat(_methods, _fields);
    } else {
      Iterable<EObject> _fields_1 = ADSLUtil.fields(type);
      Iterable<Method> _methods_1 = ADSLUtil.methods(type);
      _xifexpression = Iterables.<EObject>concat(_fields_1, _methods_1);
    }
    return _xifexpression;
  }
  
  public IScope scope_Reference_ref(final Expression context, final EReference r) {
    EObject _eContainer = context.eContainer();
    return this.symbolsDefinedBefore(_eContainer, context);
  }
  
  protected IScope _symbolsDefinedBefore(final EObject container, final EObject o) {
    EObject _eContainer = container.eContainer();
    EObject _eContainer_1 = o.eContainer();
    return this.symbolsDefinedBefore(_eContainer, _eContainer_1);
  }
  
  protected IScope _symbolsDefinedBefore(final Method m, final EObject o) {
    EList<Parameter> _params = m.getParams();
    return Scopes.scopeFor(_params);
  }
  
  protected IScope _symbolsDefinedBefore(final Block b, final EObject o) {
    EList<Statement> _statements = b.getStatements();
    Iterable<VariableDef> _variablesDeclaredBefore = this.variablesDeclaredBefore(_statements, o);
    EObject _eContainer = b.eContainer();
    EObject _eContainer_1 = o.eContainer();
    IScope _symbolsDefinedBefore = this.symbolsDefinedBefore(_eContainer, _eContainer_1);
    return Scopes.scopeFor(_variablesDeclaredBefore, _symbolsDefinedBefore);
  }
  
  private Iterable<VariableDef> variablesDeclaredBefore(final List<Statement> list, final EObject o) {
    int _indexOf = list.indexOf(o);
    List<Statement> _subList = list.subList(0, _indexOf);
    return Iterables.<VariableDef>filter(_subList, VariableDef.class);
  }
  
  public boolean isPrimitive(final XClass c) {
    Resource _eResource = c.eResource();
    return Objects.equal(_eResource, null);
  }
  
  public IScope symbolsDefinedBefore(final EObject m, final EObject o) {
    if (m instanceof Method) {
      return _symbolsDefinedBefore((Method)m, o);
    } else if (m instanceof Block) {
      return _symbolsDefinedBefore((Block)m, o);
    } else if (m != null) {
      return _symbolsDefinedBefore(m, o);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m, o).toString());
    }
  }
}
