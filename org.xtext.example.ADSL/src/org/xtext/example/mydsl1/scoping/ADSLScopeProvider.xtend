/*
 * generated by Xtext 2.9.0
 */
package org.xtext.example.mydsl1.scoping

import org.xtext.example.mydsl1.aDSL.MemberSelection
import javax.inject.Inject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.xtext.example.mydsl1.aDSL.XClass

import static extension org.xtext.example.mydsl1.util.ADSLUtil.*
import org.xtext.example.mydsl1.aDSL.Expression
import org.eclipse.emf.ecore.EObject
import org.xtext.example.mydsl1.aDSL.Method
import org.xtext.example.mydsl1.aDSL.Block
import org.xtext.example.mydsl1.aDSL.Statement
import java.util.List
import org.xtext.example.mydsl1.aDSL.VariableDef
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.xtext.example.mydsl1.lib.ADSLLib
import org.xtext.example.mydsl1.typing.ADSLTypeProvider

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ADSLScopeProvider extends AbstractDeclarativeScopeProvider {
	
	@Inject extension ADSLTypeProvider 
	@Inject extension ADSLLib

	
	def scope_VariableDef (MemberSelection sel, EReference r) {
		computeScope(sel, r)
	}
	def scope_SharedDef (MemberSelection sel, EReference r) {
		computeScope(sel, r)
	}
	def scope_Member (MemberSelection sel, EReference r) {	
		computeScope(sel, r)	
	}	
	def computeScope (MemberSelection sel, EReference r) {
		
		var parentScope = IScope::NULLSCOPE
		val type = sel.receiver.typeFor
	
		if (type == null || type.isPrimitive)
			return parentScope
		
		for (c : type.classHierarchyWithObject.reverseView) {
			parentScope = Scopes::scopeFor(c.members, parentScope)
		}
		Scopes::scopeFor(type.selectMembers(sel), parentScope)		
	}

	def selectMembers(XClass type, MemberSelection sel) {
		if (sel.methodinvocation)
			type.methods + type.fields
		else
			type.fields + type.methods
	}
	
	def scope_Reference_ref(Expression context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}

	def dispatch IScope symbolsDefinedBefore(EObject container, EObject o) {
		container.eContainer.symbolsDefinedBefore(o.eContainer)
	}

	def dispatch IScope symbolsDefinedBefore(Method m, EObject o) {
		// this ends recursion
		Scopes::scopeFor(m.params)
	}

	def dispatch IScope symbolsDefinedBefore(Block b, EObject o) {
		Scopes::scopeFor(b.statements.variablesDeclaredBefore(o), 
			b.eContainer.symbolsDefinedBefore(o.eContainer))
	}
	
	def private variablesDeclaredBefore(List<Statement> list, EObject o) {
		list.subList(0, list.indexOf(o)).filter(typeof(VariableDef))
	}

// Primitive type means the containing class is null	
	def isPrimitive(XClass c) {
		c.eResource == null
	}


}

