/*
 * generated by Xtext 2.9.0
 */
package org.xtext.example.mydsl1.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl1.aDSL.Program
import org.xtext.example.mydsl1.aDSL.XClass
import org.xtext.example.mydsl1.aDSL.Parameter
import org.eclipse.emf.common.util.EList
import org.xtext.example.mydsl1.aDSL.VariableType
import org.xtext.example.mydsl1.aDSL.StringConstant
import org.xtext.example.mydsl1.aDSL.IntConstant
import org.xtext.example.mydsl1.aDSL.BoolConstant
import org.xtext.example.mydsl1.aDSL.Statement
import org.xtext.example.mydsl1.aDSL.Operator
import org.xtext.example.mydsl1.aDSL.Expression
import org.xtext.example.mydsl1.aDSL.IfStat
import org.xtext.example.mydsl1.aDSL.WhileStat
import org.xtext.example.mydsl1.aDSL.ForStat
import org.xtext.example.mydsl1.aDSL.VarDef
import org.xtext.example.mydsl1.aDSL.VariableDef
import org.xtext.example.mydsl1.aDSL.Block
import org.xtext.example.mydsl1.aDSL.AtomicStatement
import org.xtext.example.mydsl1.aDSL.WhenStatement
import org.xtext.example.mydsl1.aDSL.For2Statement
import org.xtext.example.mydsl1.aDSL.TryCatchStat
import org.xtext.example.mydsl1.aDSL.Body
import org.xtext.example.mydsl1.aDSL.ReturnStat
import org.xtext.example.mydsl1.aDSL.AsyncStat
import org.xtext.example.mydsl1.aDSL.FinishStat
import org.xtext.example.mydsl1.aDSL.AtStat
import org.xtext.example.mydsl1.aDSL.Or
import org.xtext.example.mydsl1.aDSL.And
import org.xtext.example.mydsl1.aDSL.Equality
import org.xtext.example.mydsl1.aDSL.Comparison
import org.xtext.example.mydsl1.aDSL.MulOrDiv
import org.xtext.example.mydsl1.aDSL.Plus
import org.xtext.example.mydsl1.aDSL.Minus
import org.xtext.example.mydsl1.aDSL.Not
import org.xtext.example.mydsl1.aDSL.Assignment
import org.xtext.example.mydsl1.aDSL.MemberSelection
import org.xtext.example.mydsl1.aDSL.DeRef
import org.xtext.example.mydsl1.aDSL.This
import org.xtext.example.mydsl1.aDSL.Null
import org.xtext.example.mydsl1.aDSL.Reference
import org.xtext.example.mydsl1.aDSL.New
import org.xtext.example.mydsl1.aDSL.FuncVarDef
import org.xtext.example.mydsl1.aDSL.Init
import org.xtext.example.mydsl1.aDSL.PrintInst
import org.xtext.example.mydsl1.aDSL.SharedVarDef
import org.xtext.example.mydsl1.aDSL.Here
import org.xtext.example.mydsl1.aDSL.SharedArrayDef
import org.xtext.example.mydsl1.aDSL.SharedDef
import org.xtext.example.mydsl1.aDSL.MainMethod
import org.xtext.example.mydsl1.aDSL.Member
import org.xtext.example.mydsl1.aDSL.Method

//import org.xtext.example.mydsl1.aDSL.ImportElements

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ADSLGenerator extends AbstractGenerator {


override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (pr: res.allContents.toIterable.filter(Program)) {
			for (cl : pr.xclass) {
			fsa.generateFile("ADSL/" +	cl.name + ".x10", pr.compile)
			
			}		
		}
		
		fsa.generateFile ("ADSL/" + "Token.x10", tokenCompile)
		fsa.generateFile ("ADSL/" + "Distributions.x10", distributionCompile)
	}	
	
	def distributionCompile() {
		'''
		import x10.regionarray.DistArray;
		import x10.regionarray.Dist;
		
		public class Distributions {
			var distributions:DistArray[Dist];
			def this(dist:Dist) {
				distributions = DistArray.make[Dist](dist);
			}
			def set(p:Point, dist:Dist) {	
				distributions(p) = dist;
			}
			public operator this(p:Point) = distributions(p);
		}
		'''
	}
	
	def tokenCompile () {
		'''
		public class Token { 
			
			var token:Long;			
			def this() {				
				token = 0;
			}			
			// Take method performs token acquisition
			def take() {		
				when(token == 0) token = 1;
			}
			// Release method performs release of token
			def release() {
				atomic token = 0;
			}
		}		
		'''	
	}
	
	def compile(Program prog) {
		'''
		«FOR element : prog.importElements»
		import «element.importedNamespace»
		«ENDFOR»	
		«FOR cl : prog.xclass»«cl.compileClass»«ENDFOR»
		'''		
	}
	
	def compileClass(XClass cl) {
		'''
		public class «cl.name» {
		
			val cmp : (p1:Place, p2:Place) => Int 
				= (p1:Place, p2:Place) => {
					if (p1.id() > p2.id()) 
						return Int.operator_as(1);
					else if (p1.id() < p2.id())
						return Int.operator_as(1);
					else return Int.operator_as(0);
				};			
		
			«FOR member : cl.members»
			«IF member instanceof VariableDef»«(member as VariableDef).compile»«ELSEIF member instanceof SharedDef»«(member as SharedDef).compile»«ELSEIF member instanceof FuncVarDef»«(member as FuncVarDef).compile»«ELSEIF member instanceof Method»«(member as Method).compile»«ELSEIF member instanceof Operator»«(member as Operator).compile»«ELSEIF member instanceof PrintInst»«(member as PrintInst).compile»«ELSEIF member instanceof MainMethod»«(member as MainMethod).compile»«ENDIF»				
			«ENDFOR»		
		}
		'''
	}
	
	def compile (MainMethod member) {
		'''
		
		public static def main ( «member.type.typeToString» )
		«member.body.compile»
		'''
	}
	
	// The method does not have const when it's translated to X10
	def compile(Method member) {
		'''	
		def «member.name»(«(member as Method).params.compile»)«IF member.istyped» : «member.type.typeToString»«ENDIF» {
			«FOR s : (member as Method).body.statements»
			
			«s.switchStatement»
			«ENDFOR»
		}
		
		'''
	}
	def compile (PrintInst member) {
		'''
		Console.OUT.println(«member.expression.compile») ;
		'''
	}	
	def compile (Operator member) {
		'''
		public operator «member.opName» ( «member.params.compile» ) = «member.expression.compile» ;
		'''
	}
	
	def compile(EList<Parameter> p) {
		p.map[name + ":" + type.typeToString].join(", ")
	}
	
	def switchStatement(Statement s) {
//		System.out.println(s.toString);
		switch s {
			case s instanceof IfStat: (s as IfStat).compile
			case s instanceof AtomicStatement : (s as AtomicStatement).compile
			case s instanceof WhenStatement : (s as WhenStatement).compile
			case s instanceof For2Statement : (s as For2Statement).compile
			case s instanceof TryCatchStat : (s as TryCatchStat).compile
			case s instanceof WhileStat : (s as WhileStat).compile
			case s instanceof ForStat : (s as ForStat).compile
			case s instanceof ReturnStat : (s as ReturnStat).compile
			case s instanceof AsyncStat : (s as AsyncStat).compile
			case s instanceof FinishStat : (s as FinishStat).compile
			case s instanceof AtStat : (s as AtStat).compile
			case s instanceof SharedDef : (s as SharedDef).compile
			case s instanceof VariableDef : (s as VariableDef).compileStatVariableDef
			case s instanceof FuncVarDef : (s as FuncVarDef).compile
			case s instanceof Expression : (s as Expression).compileStatExpression
//			case s instanceof ArithExpression : (s as ArithExpression).compile
			default: 'Statement not recognized'
		}
	}	
	def compileStatVariableDef (VariableDef v) {
		'''
		«v.compile»
		'''
	}
	def compile (FuncVarDef v) {
		''''''
	}
	def compileStatExpression (Expression ex) {		
		'''
		«ex.compile»;
		'''
	}	
	def compile (AtStat s) { 
		'''
		at («s.exp.compile») «s.body.compile»
		'''
	}	
	def compile (FinishStat s) { 
		'''
		finish «s.body.compile»
		'''
	}	
	def compile (AsyncStat s) { 
		'''
		async «s.body.compile»
		'''
	}	
	def compile (ReturnStat s) {
		'''
		return «s.expression.compile»;
		'''
	}	
	def compile (For2Statement s) {
		'''
		for («s.par.name» in «s.data.compile») «s.body.compile»
		'''
	}	
	def compile (ForStat s) { 
		'''	for («s.temp.compile» «s.condition.compile»; «s.finalexp.compile») 
		«s.body.compile»'''
	}	
	def compile (WhileStat s) {
		'''
		while («s.expression.compile») «s.body.compile»
		'''
	}	
	def compile (TryCatchStat s) {
		'''
		try «s.bodyTry.compile»
		catch («s.name») «s.bodyCatch.compile»
		'''		
	}	
	def compile (Body b) {
		'''
		{
			«FOR s : b.statements»«s.switchStatement»«ENDFOR»
		}
		'''
	}
	def getVarName (VarDef s) {
		switch s {
			VariableDef : s.name
			SharedVarDef : s.name
			Parameter : s.name			
		}
	}
	def compile (WhenStatement s) {
		'''
		when(«s.expression.compile») «s.statement.switchStatement»
		'''		
	}	
	def compile (IfStat s) {
		'''
		if («s.expression.compile»){
			«s.thenBlock.compile»
		}
		«IF s.iselse»«s.elseBlock.compile»«ENDIF»
		'''
	}	
	def compile (AtomicStatement s) {
		'''
		atomic «s.statement.switchStatement»
		'''		
	}	
	def compile(Block block) {
		'''
  		«IF block.ispar == false»«block.statements.compileStatements»«ELSE»{
  			«block.statements.compileStatements»
  		}«ENDIF»
  		'''
	}
	def compileStatements(EList<Statement> stats) {
		'''		
		«FOR stat : stats»«stat.switchStatement»«ENDFOR»
		'''
	}		
	// Implementation of shared-val variable	
	
	def compile (SharedDef v) {
		'''
		«IF v.replicas == true»«IF v instanceof SharedVarDef»«(v as SharedVarDef).compileSharedVarDef_repl»«ELSE»«(v as SharedArrayDef).compileSharedArrayDef_repl»«ENDIF»
		«ELSE»«IF v.replicas == false»«IF v instanceof SharedVarDef»«(v as SharedVarDef).compileSharedVarDef_plshift»«ELSE»«(v as SharedArrayDef).compileSharedArrayDef_plshift»«ENDIF»«ENDIF»«ENDIF»
		'''
	}
	
	def compileSharedVarDef_plshift (SharedVarDef v) {
		'''
		val «v.name»:«v.type.typeToString» = «v.expression.compile»;
		val gc_«v.name» = GlobalRef[«v.type.typeToString»](«v.name»);
		'''
	}
	def compileSharedArrayDef_plshift (SharedArrayDef v) {
		'''
		val list_«v.name»
		'''	
	}	
	def compileSharedVarDef_repl (SharedVarDef v) {
		'''
		val places_«v.name»:ArrayList[Place] = «v.sym.getVarName»;
		places_«v.name».sort(cmp);
		val size__«v.name»:Long = places.size();
		val pGroup_«v.name»:Rail[Place] = new Rail[Place](s);
			for (var i:Long = 0; i < s; i++) 
				pGroup_«v.name»(i) = places_«v.name»(i);
		val placeGroup_«v.name»:PlaceGroup = new SparsePlaceGroup(pGroup);
		val d_«v.name» = Dist.makeUnique(placeGroup_«v.name»);
		val token_«v.name» = new Token();
		val gc_«v.name» = GlobalRef[Token](token_«v.name»);
		
		val «v.name»:DistArray[«v.type.typeToString»] 
		= DistArray.make[«v.type.typeToString»](d_«v.name», ([i]:Point(1) => «v.expression.compile»);		
		'''
	}
	def compileSharedArrayDef_repl(SharedArrayDef v) {
		'''
		val size_«v.name» = «v.expression.getVarName».size();
		val dist_«v.name»:Dist.makeBlock(Region.make(0, size-1));
		val distributions_«v.name»:Distributions = new Distributions(dist_«v.name»);

		var list_«v.name»:DistArray[DistArray[«v.type.typeToString»]] = DistArray.make[DistArray[«v.type.typeToString»]](dist);
		
		for (nodeId in dist) {
			«v.sym.getVarName»(nodeId).sort(cmp);
			val s_«v.name»:Long = «v.sym.getVarName»(nodeId).size();
			val pGroup_«v.name»:Rail[Place] = new Rail[Place](s_«v.name»);
			for (var i:Long = 0; i < s_«v.name»; i++) 
				pGroup_«v.name»(i) = «v.sym.getVarName»(nodeId)(i);
			val placeGroup_«v.name»:PlaceGroup = new SparsePlaceGroup(pGroup_«v.name»);
			
			val d_«v.name» = Dist.makeUnique(placeGroup_«v.name»);
			distributions_«v.name».set(nodeId, d_«v.name»);
			val rep_«v.name»:DistArray[«(v.expression as VariableDef).type.getInnerType»] = DistArray.make[«(v.expression as VariableDef).type.getInnerType»](d_«v.name», ([i]:Point(1)) => «v.expression.getVarName»(nodeId));
			list_«v.name»(nodeId) = rep_«v.name»;
		}
		'''
	}
	def getInnerType(VariableType v) {
		'''«v.innerType.typeToString»'''
	}
	
	def compile (VariableDef v) {
		'''«IF v.isstatic»static «ENDIF»«v.vartype» «v.name»«IF v.istyped»:«v.type.typeToString»«ENDIF»«IF v.isinit» = «v.expression.compile»«ENDIF»;'''
	}

	def typeToString(VariableType v) {
		if(v.isarray) v.type.xclassName + '[' + v.innerType.typeToString + ']'
		else v.type.xclassName
	}
	
	def xclassName(XClass c) {
		return c.name
	}
		
	def compile (Expression ex) {
		switch ex {
			case ex instanceof Or : (ex as Or).compile
			case ex instanceof And : (ex as And).compile
			case ex instanceof Equality: (ex as Equality).compile
			case ex instanceof Comparison: (ex as Comparison).compile
			case ex instanceof MulOrDiv : (ex as MulOrDiv).compile
			case ex instanceof Not : (ex as Not).compile
			case ex instanceof Assignment : (ex as Assignment).compile
			case ex instanceof MemberSelection : (ex as MemberSelection).compile
			case ex instanceof StringConstant : (ex as StringConstant).compile
			case ex instanceof IntConstant : (ex as IntConstant).compile
			case ex instanceof BoolConstant : (ex as BoolConstant).compile
			case ex instanceof This : (ex as This).compile
			case ex instanceof Null : (ex as Null).compile
			case ex instanceof New : (ex as New).compile
			case ex instanceof DeRef : (ex as DeRef).compile
			case ex instanceof Reference : (ex as Reference).compile
			case ex instanceof Plus : (ex as Plus).compile
			case ex instanceof Minus : (ex as Minus).compile
			case ex instanceof Init : (ex as Init).compile
			case ex instanceof Here : (ex as Here).compile
			default : "ex not recognized"			
		}
	}
	def compile (Init ex) {
		'''(«ex.type.typeToString») => «ex.expression.compile»'''
	}
		
	def compile (Or ex) {
		'''«(ex.left as And).compile» || «(ex.right as And).compile»'''		
	}
	def compile (And ex) {
		'''«(ex.left as Equality).compile» && «(ex.right as Equality).compile»'''
	}
	def compile (Equality ex) {
		'''«ex.left.compile» «ex.op» «ex.right.compile»'''
	}
	def compile (Comparison ex) {
		'''«ex.left.compile» «ex.op» «ex.right.compile»'''
	}	
	def compile (Plus ex) {
		'''«ex.left.compile» + «ex.right.compile»'''	
	}	
	def compile (Minus ex) {
		'''«ex.left.compile» - «ex.right.compile»'''
	}
	def compile (MulOrDiv ex) {
		'''«ex.left.compile» «ex.op» «ex.right.compile»'''
	}
	def compile (Not ex) {
		'''!«ex.expression.compile»'''
	}
	def compile (Assignment ex) {
		'''«ex.left.compile» = «ex.right.compile»'''
	}
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	

	
	def constMem (Member m) {
		return (m as Method).isconst
	}
	
	// This applies when there is a method invocation!
	def compile (MemberSelection ex) {
		'''«IF ex.receiver instanceof Reference && ex.methodinvocation == true»«IF (ex.receiver as Reference).base instanceof SharedVarDef»«IF (ex.member as Method).constMem»«ex.compileVarReadAccess»«ELSE»«ex.compileVarWriteAccess»«ENDIF»«ENDIF»«IF (ex.receiver as Reference).base instanceof SharedArrayDef»«IF (ex.member as Method).constMem»«ex.compileArrayReadAccess»«ELSEIF (ex.member as Method).constMem && (ex.receiver as Reference).isarray»«ex.compileArrayWriteAccess»«ENDIF»«ENDIF»«ELSE»«ex.compileGeneralAccess»«ENDIF»'''

//		if(ex.receiver instanceof Reference && (ex.receiver as Reference).base instanceof SharedVarDef)
//			if (ex.name.compileMethod == 1)
//				ex.compileReadAccess
//			else if (ex.name.compileMethod == 0)
//				ex.compileWriteAccess			
//		if(ex.receiver instanceof Reference && (ex.receiver as Reference).base instanceof SharedArrayDef)
//			if(ex.name.compileMethod == 1)
//				ex.compileArrayReadAccess
//			else if (ex.name.compileMethod == 0)	
//				ex.compileArrayWriteAccess
//		else
//			ex.compileGeneralArrayAccess
	}
	
	def compileVarWriteAccess(MemberSelection ex) {
		'''«IF ((ex.receiver as Reference).base as SharedVarDef).replicas»«ex.compileVarWriteAccess_repl»«ELSE»«ex.compileVarAccess_plshift»«ENDIF»'''
		}
	def compileArrayWriteAccess(MemberSelection ex) {
		'''«IF ((ex.receiver as Reference).base as SharedArrayDef).replicas»«ex.compileArrayWriteAccess_repl»«ELSE»«ex.compileArrayWriteAccess_plshift»«ENDIF»'''
	}
	def compileVarReadAccess(MemberSelection ex) {
		'''«IF ((ex.receiver as Reference).base as SharedVarDef).replicas»«ex.compileVarReadAccess_repl»«ELSE»«ex.compileVarAccess_plshift»«ENDIF»'''
	}
	def compileArrayReadAccess(MemberSelection ex) {
		'''«IF ((ex.receiver as Reference).base as SharedArrayDef).replicas»«ex.compileArrayReadAccess_repl»«ELSE»«ex.compileArrayReadAccess_plshift»«ENDIF»'''
	}	
	
	//Below applies when a method is invoked on shared object 
	//==============================================================
	
	
	def compileVarWriteAccess_repl(MemberSelection ex) {
		'''
		at(gc_«(ex.receiver as Reference).base.getVarName».home) gc_«(ex.receiver as Reference).base.getVarName»().take();
		for (replica in «(ex.receiver as Reference).base.getVarName») async 
			«(ex.receiver as Reference).base.getVarName»(replica).«ex.member.memberName»«IF ex.methodinvocation»(«ex.args.compileArgs»);«ENDIF»
		at(gc_«(ex.receiver as Reference).base.getVarName».home) gc_«(ex.receiver as Reference).base.getVarName»().release()'''
	}
	def compileVarReadAccess_repl(MemberSelection ex) {
		'''«ex.receiver.compile».«ex.member.memberName»«IF ex.methodinvocation»(«ex.args.compileArgs»)«ENDIF»'''
	}
	def compileVarAccess_plshift(MemberSelection ex) {
		'''at(gc_«(ex.receiver as Reference).base.getVarName».home) gc_«(ex.receiver as Reference).base.getVarName»().«ex.member.memberName»«IF ex.methodinvocation»(«ex.args.compileArgs»)«ENDIF»'''
	}	
	
	
	//================================================================	
	def compileArrayWriteAccess_repl(MemberSelection ex) {
//		'''
//		val tempRepl_«(ex.receiver as Reference).base.name»:DistArray[«(((ex.receiver as Reference).base as SharedArrayDef).expression as VariableDef).type.getInnerType»] = list_«(ex.receiver as Reference).base.name»(«ex.name»);
//		//Updating elements in parallel
//		for (r in tempRepl_«(ex.receiver as Reference).base.name») async at(tempRepl_«(ex.receiver as Reference).base.name».dist(r))
//		tempRepl_«(ex.receiver as Reference).base.name»(r)«IF ex.methodinvocation»(«ex.args.compileArgs»)«ENDIF»
//		'''
	}
	def compileArrayReadAccess_repl(MemberSelection ex) {
//		'''«ex.receiver.compile».«ex.name.parseName»«IF ex.methodinvocation»(«ex.args.compileArgs»)«ENDIF»'''
	}	
	def compileArrayWriteAccess_plshift(MemberSelection ex) {
		
	}
	def compileArrayReadAccess_plshift(MemberSelection ex) {
		
	}
	def compileGeneralAccess(MemberSelection ex) {
		'''«ex.receiver.compile».«ex.member.memberName»«IF ex.methodinvocation»(«ex.args.compileArgs»)«ENDIF»'''
	}
	
	// Applied on a reference
	//---------------------------------------------------------------------
	def compile (Reference term) {
		'''«IF term.base instanceof SharedVarDef»«(term.base as SharedVarDef).compileVarRef»«ELSEIF term.base instanceof SharedArrayDef»«IF term.isarray == false»«term.compileSharedArrayDef_1»«ELSE»«term.compileArrayRef»«ENDIF»«ELSE»«term.compileGeneralVar»«ENDIF»'''
	}
	//---------------------------------------------------------------------
	
	def compileVarRef (SharedVarDef v) {
		'''«IF v.replicas»«v.compileSharedVarRef_repl»«ELSE»«v.compileSharedVarRef_plshift»«ENDIF»'''
	}
	def compileArrayRef (Reference term) {
		'''«IF (term.base as SharedArrayDef).replicas»«term.compileSharedArrayRef_repl»«ELSE»«term.compileSharedArrayRef_plshift»«ENDIF»'''
	}		 
			 
	def memberName (Member m) {
		if (m instanceof Method) (m as Method).name
		else if (m instanceof VariableDef) (m as VariableDef).name
		else if (m instanceof SharedVarDef) (m as SharedVarDef).name
		else if (m instanceof SharedArrayDef) (m as SharedArrayDef).name
	}
//	def parseName (String name) {
//		return name.split('_').get(0)
//	}
//	def compileMethod (String name) {
//		try {
//			switch name {
//				case name.split('_').get(1) == 'const' : 1
////				case name.split('_').get(1) == 'r' : 1
//				default : 0
//		} 
//		}catch(Exception ex) {
//			return 0			
//		}
//	}	
	
	// ===== Compile reference
	
	def compileSharedVarRef_repl(SharedVarDef v) {
		'''«v.name»(here.id())'''
	}
	def compileSharedVarRef_plshift(SharedVarDef v) {
		'''at (gc_«v.name».home) gc_«v.name»()'''
	}
	// Applies to the case when a shared array is referenced
	def compileSharedArrayDef_1(Reference term) {
		'''«term.base.getVarName»'''
	}
	// Applies to the case when a shared array MEMBER is referenced
	def compileSharedArrayRef_repl(Reference term) {
		'''((at(dist_«(term.base.getVarName)»(«FOR param : term.params»«param.compile»))«ENDFOR»list_«(term.base.getVarName)»(«FOR param : term.params»«param.compile»«ENDFOR»))(((at(dist_«term.base.getVarName»(«FOR param : term.params»«param.compile»«ENDFOR»)) distributions_«(term.base.getVarName)»(«FOR param : term.params»«param.compile»))«ENDFOR»)).get(here)).maxPoint()))'''
	}
	def compileSharedArrayRef_plshift(Reference term) {
		
	}
	
	// = Compiles the general Reference case - non-shared variable
	def compileGeneralVar(Reference term) {
		'''«term.base.getVarName»«IF term.isarray»(«FOR param : term.params»«param.compile»«ENDFOR»)«ENDIF»'''
	}		
	
	
	// Below compiles terminal symbols 

	//for symbolic references
//	def switchVariable(VarDef s) {
//		switch s {
////			case s instanceof TempVar:
//			case s instanceof VarDef : s.name
//			case s instanceof Parameter : s.name
//			case s instanceof FuncVarDef : s.name
//			case s instanceof SharedVarDef : s.name
//		}
//	}	

	
	def compileArgs(EList<Expression> ex) {
		ex.map[compile].join(", ")
	}
	def compile (StringConstant term) {
		'''«term.value»'''		
	}
	def compile (BoolConstant term) {
		'''«term.value»'''
	}
	def compile (IntConstant term) {
		'''«IF term.value.isneg»-«ENDIF»«term.value.value»'''
	}
	def compile (DeRef term) {
		'''«term.ref.getVarName»()'''
	}
	def compile (This term) {
		'''this'''
	}
	def compile (Null term) {
		'''null'''
	}
	def compile (New term) {
		'''new «term.type.typeToString»(«term.args.compileArgs»)'''		
	}
	def compile (Here term) {
		'''here'''
	}
}
