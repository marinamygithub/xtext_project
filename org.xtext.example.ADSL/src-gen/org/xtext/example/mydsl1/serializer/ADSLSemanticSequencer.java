/*
 * generated by Xtext 2.9.0
 */
package org.xtext.example.mydsl1.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl1.aDSL.ADSLPackage;
import org.xtext.example.mydsl1.aDSL.AbstractElements;
import org.xtext.example.mydsl1.aDSL.And;
import org.xtext.example.mydsl1.aDSL.Assignment;
import org.xtext.example.mydsl1.aDSL.AsyncStat;
import org.xtext.example.mydsl1.aDSL.AtStat;
import org.xtext.example.mydsl1.aDSL.AtomicStatement;
import org.xtext.example.mydsl1.aDSL.Block;
import org.xtext.example.mydsl1.aDSL.Body;
import org.xtext.example.mydsl1.aDSL.BoolConstant;
import org.xtext.example.mydsl1.aDSL.Comparison;
import org.xtext.example.mydsl1.aDSL.DeRef;
import org.xtext.example.mydsl1.aDSL.Equality;
import org.xtext.example.mydsl1.aDSL.FinishStat;
import org.xtext.example.mydsl1.aDSL.For2Statement;
import org.xtext.example.mydsl1.aDSL.ForStat;
import org.xtext.example.mydsl1.aDSL.FuncVarDef;
import org.xtext.example.mydsl1.aDSL.Here;
import org.xtext.example.mydsl1.aDSL.IfStat;
import org.xtext.example.mydsl1.aDSL.Init;
import org.xtext.example.mydsl1.aDSL.IntConstant;
import org.xtext.example.mydsl1.aDSL.IntegerNegative;
import org.xtext.example.mydsl1.aDSL.MainMethod;
import org.xtext.example.mydsl1.aDSL.MemberSelection;
import org.xtext.example.mydsl1.aDSL.Method;
import org.xtext.example.mydsl1.aDSL.Minus;
import org.xtext.example.mydsl1.aDSL.MulOrDiv;
import org.xtext.example.mydsl1.aDSL.New;
import org.xtext.example.mydsl1.aDSL.Not;
import org.xtext.example.mydsl1.aDSL.Null;
import org.xtext.example.mydsl1.aDSL.Operator;
import org.xtext.example.mydsl1.aDSL.Or;
import org.xtext.example.mydsl1.aDSL.Plus;
import org.xtext.example.mydsl1.aDSL.PrintInst;
import org.xtext.example.mydsl1.aDSL.Program;
import org.xtext.example.mydsl1.aDSL.Reference;
import org.xtext.example.mydsl1.aDSL.ReturnStat;
import org.xtext.example.mydsl1.aDSL.SharedArrayDef;
import org.xtext.example.mydsl1.aDSL.SharedVarDef;
import org.xtext.example.mydsl1.aDSL.StringConstant;
import org.xtext.example.mydsl1.aDSL.This;
import org.xtext.example.mydsl1.aDSL.TryCatchStat;
import org.xtext.example.mydsl1.aDSL.VariableDef;
import org.xtext.example.mydsl1.aDSL.VariableType;
import org.xtext.example.mydsl1.aDSL.WhenStatement;
import org.xtext.example.mydsl1.aDSL.WhileStat;
import org.xtext.example.mydsl1.aDSL.XClass;
import org.xtext.example.mydsl1.services.ADSLGrammarAccess;

@SuppressWarnings("all")
public class ADSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ADSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ADSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ADSLPackage.ABSTRACT_ELEMENTS:
				sequence_AbstractElements(context, (AbstractElements) semanticObject); 
				return; 
			case ADSLPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ADSLPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ADSLPackage.ASYNC_STAT:
				sequence_AsyncStat(context, (AsyncStat) semanticObject); 
				return; 
			case ADSLPackage.AT_STAT:
				sequence_AtStat(context, (AtStat) semanticObject); 
				return; 
			case ADSLPackage.ATOMIC_STATEMENT:
				sequence_AtomicStatement(context, (AtomicStatement) semanticObject); 
				return; 
			case ADSLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ADSLPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case ADSLPackage.BOOL_CONSTANT:
				sequence_TerminalExpression(context, (BoolConstant) semanticObject); 
				return; 
			case ADSLPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case ADSLPackage.DE_REF:
				sequence_TerminalExpression(context, (DeRef) semanticObject); 
				return; 
			case ADSLPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case ADSLPackage.FINISH_STAT:
				sequence_FinishStat(context, (FinishStat) semanticObject); 
				return; 
			case ADSLPackage.FOR2_STATEMENT:
				sequence_For2Statement(context, (For2Statement) semanticObject); 
				return; 
			case ADSLPackage.FOR_STAT:
				sequence_ForStatement(context, (ForStat) semanticObject); 
				return; 
			case ADSLPackage.FUNC_VAR_DEF:
				sequence_FuncVarDef(context, (FuncVarDef) semanticObject); 
				return; 
			case ADSLPackage.HERE:
				sequence_TerminalExpression(context, (Here) semanticObject); 
				return; 
			case ADSLPackage.IF_STAT:
				sequence_IfStatement(context, (IfStat) semanticObject); 
				return; 
			case ADSLPackage.INIT:
				sequence_TerminalExpression(context, (Init) semanticObject); 
				return; 
			case ADSLPackage.INT_CONSTANT:
				sequence_TerminalExpression(context, (IntConstant) semanticObject); 
				return; 
			case ADSLPackage.INTEGER_NEGATIVE:
				sequence_IntegerNegative(context, (IntegerNegative) semanticObject); 
				return; 
			case ADSLPackage.MAIN_METHOD:
				sequence_MainMethod(context, (MainMethod) semanticObject); 
				return; 
			case ADSLPackage.MEMBER_SELECTION:
				sequence_SelectionExpression(context, (MemberSelection) semanticObject); 
				return; 
			case ADSLPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case ADSLPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case ADSLPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case ADSLPackage.NEW:
				sequence_TerminalExpression(context, (New) semanticObject); 
				return; 
			case ADSLPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case ADSLPackage.NULL:
				sequence_TerminalExpression(context, (Null) semanticObject); 
				return; 
			case ADSLPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case ADSLPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case ADSLPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.example.mydsl1.aDSL.Parameter) semanticObject); 
				return; 
			case ADSLPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case ADSLPackage.PRINT_INST:
				sequence_PrintInst(context, (PrintInst) semanticObject); 
				return; 
			case ADSLPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ADSLPackage.REFERENCE:
				sequence_TerminalExpression(context, (Reference) semanticObject); 
				return; 
			case ADSLPackage.RETURN_STAT:
				sequence_ReturnStatement(context, (ReturnStat) semanticObject); 
				return; 
			case ADSLPackage.SHARED_ARRAY_DEF:
				sequence_SharedArrayDef(context, (SharedArrayDef) semanticObject); 
				return; 
			case ADSLPackage.SHARED_VAR_DEF:
				sequence_SharedVarDef(context, (SharedVarDef) semanticObject); 
				return; 
			case ADSLPackage.STRING_CONSTANT:
				sequence_TerminalExpression(context, (StringConstant) semanticObject); 
				return; 
			case ADSLPackage.THIS:
				sequence_TerminalExpression(context, (This) semanticObject); 
				return; 
			case ADSLPackage.TRY_CATCH_STAT:
				sequence_TryCatchBlock(context, (TryCatchStat) semanticObject); 
				return; 
			case ADSLPackage.VARIABLE_DEF:
				sequence_VariableDef(context, (VariableDef) semanticObject); 
				return; 
			case ADSLPackage.VARIABLE_TYPE:
				sequence_VariableType(context, (VariableType) semanticObject); 
				return; 
			case ADSLPackage.WHEN_STATEMENT:
				sequence_WhenStatement(context, (WhenStatement) semanticObject); 
				return; 
			case ADSLPackage.WHILE_STAT:
				sequence_WhileStatement(context, (WhileStat) semanticObject); 
				return; 
			case ADSLPackage.XCLASS:
				sequence_XClass(context, (XClass) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractElements returns AbstractElements
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_AbstractElements(ISerializationContext context, AbstractElements semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.ABSTRACT_ELEMENTS__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.ABSTRACT_ELEMENTS__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbstractElementsAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Expression returns Assignment
	 *     ArithExpression returns Assignment
	 *     Assignment returns Assignment
	 *     Or returns Assignment
	 *     Or.Or_1_0 returns Assignment
	 *     And returns Assignment
	 *     And.And_1_0 returns Assignment
	 *     Equality returns Assignment
	 *     Equality.Equality_1_0 returns Assignment
	 *     Comparison returns Assignment
	 *     Comparison.Comparison_1_0 returns Assignment
	 *     PlusOrMinus returns Assignment
	 *     PlusOrMinus.Plus_1_0_0_0 returns Assignment
	 *     PlusOrMinus.Minus_1_0_1_0 returns Assignment
	 *     MulOrDiv returns Assignment
	 *     MulOrDiv.MulOrDiv_1_0 returns Assignment
	 *     Primary returns Assignment
	 *
	 * Constraint:
	 *     (left=Assignment_Assignment_1_0 right=ArithExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getRightArithExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AsyncStat
	 *     AsyncStat returns AsyncStat
	 *
	 * Constraint:
	 *     body=Block
	 */
	protected void sequence_AsyncStat(ISerializationContext context, AsyncStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.ASYNC_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.ASYNC_STAT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsyncStatAccess().getBodyBlockParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AtStat
	 *     AtStat returns AtStat
	 *
	 * Constraint:
	 *     (exp=SelectionExpression body=Block)
	 */
	protected void sequence_AtStat(ISerializationContext context, AtStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.AT_STAT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.AT_STAT__EXP));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.AT_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.AT_STAT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtStatAccess().getExpSelectionExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getAtStatAccess().getBodyBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AtomicStatement
	 *     AtomicStatement returns AtomicStatement
	 *
	 * Constraint:
	 *     statement=Statement
	 */
	protected void sequence_AtomicStatement(ISerializationContext context, AtomicStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.ATOMIC_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.ATOMIC_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicStatementAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement | (ispar?='{' statements+=Statement+))
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='<=' | op='>=' | op='<' | op='>') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FinishStat
	 *     FinishStat returns FinishStat
	 *
	 * Constraint:
	 *     body=Block
	 */
	protected void sequence_FinishStat(ISerializationContext context, FinishStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FINISH_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FINISH_STAT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinishStatAccess().getBodyBlockParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns For2Statement
	 *     For2Statement returns For2Statement
	 *
	 * Constraint:
	 *     (par=Parameter data=TerminalExpression body=Block)
	 */
	protected void sequence_For2Statement(ISerializationContext context, For2Statement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__PAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__PAR));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__DATA));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR2_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFor2StatementAccess().getParParameterParserRuleCall_2_0(), semanticObject.getPar());
		feeder.accept(grammarAccess.getFor2StatementAccess().getDataTerminalExpressionParserRuleCall_4_0(), semanticObject.getData());
		feeder.accept(grammarAccess.getFor2StatementAccess().getBodyBlockParserRuleCall_6_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStat
	 *     ForStatement returns ForStat
	 *
	 * Constraint:
	 *     (temp=VariableDef condition=ArithExpression finalexp=Expression body=Block)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR_STAT__TEMP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR_STAT__TEMP));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR_STAT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR_STAT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR_STAT__FINALEXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR_STAT__FINALEXP));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.FOR_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.FOR_STAT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getTempVariableDefParserRuleCall_3_0(), semanticObject.getTemp());
		feeder.accept(grammarAccess.getForStatementAccess().getConditionArithExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForStatementAccess().getFinalexpExpressionParserRuleCall_6_0(), semanticObject.getFinalexp());
		feeder.accept(grammarAccess.getForStatementAccess().getBodyBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns FuncVarDef
	 *     FuncVarDef returns FuncVarDef
	 *     Statement returns FuncVarDef
	 *     VarDef returns FuncVarDef
	 *
	 * Constraint:
	 *     (name=ID (params+=Parameter params+=Parameter*)? type=VariableType (params+=Parameter params+=Parameter*)? body=Body)
	 */
	protected void sequence_FuncVarDef(ISerializationContext context, FuncVarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStat
	 *     IfStatement returns IfStat
	 *
	 * Constraint:
	 *     (expression=ArithExpression thenBlock=Block (iselse?='else' elseBlock=Block)?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntegerNegative returns IntegerNegative
	 *
	 * Constraint:
	 *     (isneg?='-'? value=INT)
	 */
	protected void sequence_IntegerNegative(ISerializationContext context, IntegerNegative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns MainMethod
	 *     MainMethod returns MainMethod
	 *
	 * Constraint:
	 *     (type=VariableType body=Body)
	 */
	protected void sequence_MainMethod(ISerializationContext context, MainMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.MAIN_METHOD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.MAIN_METHOD__TYPE));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.MAIN_METHOD__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.MAIN_METHOD__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMainMethodAccess().getTypeVariableTypeParserRuleCall_5_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMainMethodAccess().getBodyBodyParserRuleCall_7_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Method
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (isconst?='const'? (name=ID | name='this') (params+=Parameter params+=Parameter*)? (istyped?=':' type=VariableType)? body=Body)
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equality returns MulOrDiv
	 *     Equality.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparison_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Operator
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     ((opName=ID | opName='this') (params+=Parameter params+=Parameter*)? expression=Expression)
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     VarDef returns Parameter
	 *
	 * Constraint:
	 *     (name=ID (istyped?=':' type=VariableType)?)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.example.mydsl1.aDSL.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithExpression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.MulOrDiv_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns PrintInst
	 *     PrintInst returns PrintInst
	 *     Statement returns PrintInst
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintInst(ISerializationContext context, PrintInst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.PRINT_INST__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.PRINT_INST__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintInstAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     ((name=QualifiedName? importElements+=AbstractElements+ xclass+=XClass+) | (name=QualifiedName? xclass+=XClass+) | xclass+=XClass+)?
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStat
	 *     ReturnStatement returns ReturnStat
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.RETURN_STAT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.RETURN_STAT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MemberSelection
	 *     Expression returns MemberSelection
	 *     ArithExpression returns MemberSelection
	 *     Assignment returns MemberSelection
	 *     Assignment.Assignment_1_0 returns MemberSelection
	 *     SelectionExpression returns MemberSelection
	 *     SelectionExpression.MemberSelection_1_0 returns MemberSelection
	 *     Or returns MemberSelection
	 *     Or.Or_1_0 returns MemberSelection
	 *     And returns MemberSelection
	 *     And.And_1_0 returns MemberSelection
	 *     Equality returns MemberSelection
	 *     Equality.Equality_1_0 returns MemberSelection
	 *     Comparison returns MemberSelection
	 *     Comparison.Comparison_1_0 returns MemberSelection
	 *     PlusOrMinus returns MemberSelection
	 *     PlusOrMinus.Plus_1_0_0_0 returns MemberSelection
	 *     PlusOrMinus.Minus_1_0_1_0 returns MemberSelection
	 *     MulOrDiv returns MemberSelection
	 *     MulOrDiv.MulOrDiv_1_0 returns MemberSelection
	 *     Primary returns MemberSelection
	 *
	 * Constraint:
	 *     (
	 *         receiver=SelectionExpression_MemberSelection_1_0 
	 *         member=[Member|ID] 
	 *         (ispar?='[' par=[XClass|ID])? 
	 *         (methodinvocation?='(' (args+=Expression args+=Expression*)?)?
	 *     )
	 */
	protected void sequence_SelectionExpression(ISerializationContext context, MemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns SharedArrayDef
	 *     SharedArrayDef returns SharedArrayDef
	 *     Statement returns SharedArrayDef
	 *     VarDef returns SharedArrayDef
	 *     SharedDef returns SharedArrayDef
	 *
	 * Constraint:
	 *     (replicas?='replicas'? name=ID type=VariableType sym=[VarDef|ID] expression=[VariableDef|ID])
	 */
	protected void sequence_SharedArrayDef(ISerializationContext context, SharedArrayDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns SharedVarDef
	 *     SharedVarDef returns SharedVarDef
	 *     Statement returns SharedVarDef
	 *     VarDef returns SharedVarDef
	 *     SharedDef returns SharedVarDef
	 *
	 * Constraint:
	 *     (replicas?='replicas'? name=ID type=VariableType sym=[VarDef|ID] expression=Expression)
	 */
	protected void sequence_SharedVarDef(ISerializationContext context, SharedVarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoolConstant
	 *     Expression returns BoolConstant
	 *     ArithExpression returns BoolConstant
	 *     Assignment returns BoolConstant
	 *     Assignment.Assignment_1_0 returns BoolConstant
	 *     SelectionExpression returns BoolConstant
	 *     SelectionExpression.MemberSelection_1_0 returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     TerminalExpression returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeRef
	 *     Expression returns DeRef
	 *     ArithExpression returns DeRef
	 *     Assignment returns DeRef
	 *     Assignment.Assignment_1_0 returns DeRef
	 *     SelectionExpression returns DeRef
	 *     SelectionExpression.MemberSelection_1_0 returns DeRef
	 *     Or returns DeRef
	 *     Or.Or_1_0 returns DeRef
	 *     And returns DeRef
	 *     And.And_1_0 returns DeRef
	 *     Equality returns DeRef
	 *     Equality.Equality_1_0 returns DeRef
	 *     Comparison returns DeRef
	 *     Comparison.Comparison_1_0 returns DeRef
	 *     PlusOrMinus returns DeRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns DeRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns DeRef
	 *     MulOrDiv returns DeRef
	 *     MulOrDiv.MulOrDiv_1_0 returns DeRef
	 *     Primary returns DeRef
	 *     TerminalExpression returns DeRef
	 *
	 * Constraint:
	 *     ref=[VarDef|ID]
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, DeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.DE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.DE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getRefVarDefIDTerminalRuleCall_3_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Here
	 *     Expression returns Here
	 *     ArithExpression returns Here
	 *     Assignment returns Here
	 *     Assignment.Assignment_1_0 returns Here
	 *     SelectionExpression returns Here
	 *     SelectionExpression.MemberSelection_1_0 returns Here
	 *     Or returns Here
	 *     Or.Or_1_0 returns Here
	 *     And returns Here
	 *     And.And_1_0 returns Here
	 *     Equality returns Here
	 *     Equality.Equality_1_0 returns Here
	 *     Comparison returns Here
	 *     Comparison.Comparison_1_0 returns Here
	 *     PlusOrMinus returns Here
	 *     PlusOrMinus.Plus_1_0_0_0 returns Here
	 *     PlusOrMinus.Minus_1_0_1_0 returns Here
	 *     MulOrDiv returns Here
	 *     MulOrDiv.MulOrDiv_1_0 returns Here
	 *     Primary returns Here
	 *     TerminalExpression returns Here
	 *
	 * Constraint:
	 *     {Here}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Here semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Init
	 *     Expression returns Init
	 *     ArithExpression returns Init
	 *     Assignment returns Init
	 *     Assignment.Assignment_1_0 returns Init
	 *     SelectionExpression returns Init
	 *     SelectionExpression.MemberSelection_1_0 returns Init
	 *     Or returns Init
	 *     Or.Or_1_0 returns Init
	 *     And returns Init
	 *     And.And_1_0 returns Init
	 *     Equality returns Init
	 *     Equality.Equality_1_0 returns Init
	 *     Comparison returns Init
	 *     Comparison.Comparison_1_0 returns Init
	 *     PlusOrMinus returns Init
	 *     PlusOrMinus.Plus_1_0_0_0 returns Init
	 *     PlusOrMinus.Minus_1_0_1_0 returns Init
	 *     MulOrDiv returns Init
	 *     MulOrDiv.MulOrDiv_1_0 returns Init
	 *     Primary returns Init
	 *     TerminalExpression returns Init
	 *
	 * Constraint:
	 *     (type=VariableType expression=TerminalExpression)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Init semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.INIT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.INIT__TYPE));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.INIT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.INIT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getTypeVariableTypeParserRuleCall_9_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getExpressionTerminalExpressionParserRuleCall_9_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntConstant
	 *     Expression returns IntConstant
	 *     ArithExpression returns IntConstant
	 *     Assignment returns IntConstant
	 *     Assignment.Assignment_1_0 returns IntConstant
	 *     SelectionExpression returns IntConstant
	 *     SelectionExpression.MemberSelection_1_0 returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     TerminalExpression returns IntConstant
	 *
	 * Constraint:
	 *     value=IntegerNegative
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getValueIntegerNegativeParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns New
	 *     Expression returns New
	 *     ArithExpression returns New
	 *     Assignment returns New
	 *     Assignment.Assignment_1_0 returns New
	 *     SelectionExpression returns New
	 *     SelectionExpression.MemberSelection_1_0 returns New
	 *     Or returns New
	 *     Or.Or_1_0 returns New
	 *     And returns New
	 *     And.And_1_0 returns New
	 *     Equality returns New
	 *     Equality.Equality_1_0 returns New
	 *     Comparison returns New
	 *     Comparison.Comparison_1_0 returns New
	 *     PlusOrMinus returns New
	 *     PlusOrMinus.Plus_1_0_0_0 returns New
	 *     PlusOrMinus.Minus_1_0_1_0 returns New
	 *     MulOrDiv returns New
	 *     MulOrDiv.MulOrDiv_1_0 returns New
	 *     Primary returns New
	 *     TerminalExpression returns New
	 *
	 * Constraint:
	 *     (type=VariableType (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, New semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Null
	 *     Expression returns Null
	 *     ArithExpression returns Null
	 *     Assignment returns Null
	 *     Assignment.Assignment_1_0 returns Null
	 *     SelectionExpression returns Null
	 *     SelectionExpression.MemberSelection_1_0 returns Null
	 *     Or returns Null
	 *     Or.Or_1_0 returns Null
	 *     And returns Null
	 *     And.And_1_0 returns Null
	 *     Equality returns Null
	 *     Equality.Equality_1_0 returns Null
	 *     Comparison returns Null
	 *     Comparison.Comparison_1_0 returns Null
	 *     PlusOrMinus returns Null
	 *     PlusOrMinus.Plus_1_0_0_0 returns Null
	 *     PlusOrMinus.Minus_1_0_1_0 returns Null
	 *     MulOrDiv returns Null
	 *     MulOrDiv.MulOrDiv_1_0 returns Null
	 *     Primary returns Null
	 *     TerminalExpression returns Null
	 *
	 * Constraint:
	 *     {Null}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Null semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Reference
	 *     Expression returns Reference
	 *     ArithExpression returns Reference
	 *     Assignment returns Reference
	 *     Assignment.Assignment_1_0 returns Reference
	 *     SelectionExpression returns Reference
	 *     SelectionExpression.MemberSelection_1_0 returns Reference
	 *     Or returns Reference
	 *     Or.Or_1_0 returns Reference
	 *     And returns Reference
	 *     And.And_1_0 returns Reference
	 *     Equality returns Reference
	 *     Equality.Equality_1_0 returns Reference
	 *     Comparison returns Reference
	 *     Comparison.Comparison_1_0 returns Reference
	 *     PlusOrMinus returns Reference
	 *     PlusOrMinus.Plus_1_0_0_0 returns Reference
	 *     PlusOrMinus.Minus_1_0_1_0 returns Reference
	 *     MulOrDiv returns Reference
	 *     MulOrDiv.MulOrDiv_1_0 returns Reference
	 *     Primary returns Reference
	 *     TerminalExpression returns Reference
	 *
	 * Constraint:
	 *     (base=[VarDef|ID] (isarray?='(' params+=SelectionExpression)?)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringConstant
	 *     Expression returns StringConstant
	 *     ArithExpression returns StringConstant
	 *     Assignment returns StringConstant
	 *     Assignment.Assignment_1_0 returns StringConstant
	 *     SelectionExpression returns StringConstant
	 *     SelectionExpression.MemberSelection_1_0 returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparison_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     TerminalExpression returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns This
	 *     Expression returns This
	 *     ArithExpression returns This
	 *     Assignment returns This
	 *     Assignment.Assignment_1_0 returns This
	 *     SelectionExpression returns This
	 *     SelectionExpression.MemberSelection_1_0 returns This
	 *     Or returns This
	 *     Or.Or_1_0 returns This
	 *     And returns This
	 *     And.And_1_0 returns This
	 *     Equality returns This
	 *     Equality.Equality_1_0 returns This
	 *     Comparison returns This
	 *     Comparison.Comparison_1_0 returns This
	 *     PlusOrMinus returns This
	 *     PlusOrMinus.Plus_1_0_0_0 returns This
	 *     PlusOrMinus.Minus_1_0_1_0 returns This
	 *     MulOrDiv returns This
	 *     MulOrDiv.MulOrDiv_1_0 returns This
	 *     Primary returns This
	 *     TerminalExpression returns This
	 *
	 * Constraint:
	 *     {This}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TryCatchStat
	 *     TryCatchBlock returns TryCatchStat
	 *
	 * Constraint:
	 *     (bodyTry=Body name=ID bodyCatch=Body)
	 */
	protected void sequence_TryCatchBlock(ISerializationContext context, TryCatchStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__BODY_TRY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__BODY_TRY));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__NAME));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__BODY_CATCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.TRY_CATCH_STAT__BODY_CATCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTryCatchBlockAccess().getBodyTryBodyParserRuleCall_2_0(), semanticObject.getBodyTry());
		feeder.accept(grammarAccess.getTryCatchBlockAccess().getNameIDTerminalRuleCall_5_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTryCatchBlockAccess().getBodyCatchBodyParserRuleCall_7_0(), semanticObject.getBodyCatch());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns VariableDef
	 *     VariableDef returns VariableDef
	 *     Statement returns VariableDef
	 *     VarDef returns VariableDef
	 *
	 * Constraint:
	 *     (isstatic?='static'? (vartype='var' | vartype='val') name=ID (istyped?=':' type=VariableType)? (isinit?='=' expression=ArithExpression)?)
	 */
	protected void sequence_VariableDef(ISerializationContext context, VariableDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableType returns VariableType
	 *     VarDef returns VariableType
	 *
	 * Constraint:
	 *     (type=[XClass|QualifiedName] (isarray?='[' innerType=VariableType)?)
	 */
	protected void sequence_VariableType(ISerializationContext context, VariableType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhenStatement
	 *     WhenStatement returns WhenStatement
	 *
	 * Constraint:
	 *     (expression=Equality statement=Statement)
	 */
	protected void sequence_WhenStatement(ISerializationContext context, WhenStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.WHEN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.WHEN_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.WHEN_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.WHEN_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhenStatementAccess().getExpressionEqualityParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhenStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStat
	 *     WhileStatement returns WhileStat
	 *
	 * Constraint:
	 *     (expression=Expression body=Body)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.WHILE_STAT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.WHILE_STAT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ADSLPackage.Literals.WHILE_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ADSLPackage.Literals.WHILE_STAT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyBodyParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XClass returns XClass
	 *     VarDef returns XClass
	 *
	 * Constraint:
	 *     (name=ID superclass=[XClass|QualifiedName]? members+=Member*)
	 */
	protected void sequence_XClass(ISerializationContext context, XClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
